<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallet Created</title>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f8f9fa;
            color: #343a40;
            font-family: 'Arial', sans-serif;
        }

        .container {
            margin-top: 50px;
            padding: 0 20px; /* Side padding for main container */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .content-row {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 40px;
        }

        .content {
            flex: 1;
            margin-right: 20px;
            max-width: 550px;
        }

        .main-header {
            text-align: left;
            margin-bottom: 20px;
        }

        .main-header h2 {
            font-size: 2.5rem;
            font-weight: bold;
            line-height: 1.2;
        }

        .form-section {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 550px;
        }

        .btn-primary,
        .btn-secondary {
            padding: 15px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border: none;
            transition: box-shadow 0.3s;
            font-size: 1rem;
            width: 100%;
        }

        .btn-primary:hover,
        .btn-secondary:hover {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        .wallet-button {
            margin: 15px 0;
        }

        .settings-history-section {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-top: 40px;
            width: 100%;
            text-align: center;
        }

        .settings-button,
        .history-button {
            padding: 15px 30px;
            border-radius: 8px;
            border: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.3s;
            font-size: 1rem;
            width: 45%;
            margin: 10px;
        }

        .settings-button:hover,
        .history-button:hover {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        .logo {
            flex: 0 0 550px; /* The logo size is fixed */
            display: flex;
            align-items: center;
            justify-content: center;
            height: 700px;
            margin-right: 120px;
        }

        .logo img {
            width: 100%;
            height: auto;
            object-fit: contain;
        }

        /* Modal windows are hidden by default */
        .modal {
            display: none;
            position: fixed;
            z-index: 1050;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.5);
            padding-top: 60px;
        }

        .modal-content {
            background-color: #ffffff;
            margin: auto;
            border-radius: 15px;
            border: 1px solid #888;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            /* Left/Right indent added */
            padding: 40px 20px;
        }

        .modal-header {
            border-bottom: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-footer {
            border-top: none;
            margin-top: 20px;
        }

        label,
        p {
            color: #343a40;
        }

        .form-control {
            background-color: #f8f9fa;
            color: #343a40;
            border: 1px solid #ced4da;
            border-radius: 10px;
            padding: 15px;
            font-size: 1.1rem;
        }

        .form-control:focus {
            background-color: #ffffff;
            color: #343a40;
            border-color: #28a745;
        }

        .select-token {
            background-color: #f8f9fa;
            color: #343a40;
            border: 1px solid #ced4da;
            border-radius: 10px;
            padding: 10px;
            font-size: 1.1rem;
            flex: 1;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .select-token:focus {
            background-color: #ffffff;
            border-color: #28a745;
        }

        .token-select-container {
            display: flex;
            align-items: center;
            gap: 20px; /* Space between label and selector */
            margin-bottom: 5px; /* Spacing between selection lines */
        }

        .close {
            color: #aaa;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
        }

        .error {
            color: red;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Section with balances and logo in one row -->
        <div class="content-row">
            <div class="content">
                <div class="main-header">
                    <p style="font-size: 1.25rem;"><strong>Address:</strong> {{ address }}</p>
                </div>

                <div class="form-section">
                    {% if chain == 'evm' %}
                    <h3>EVM Balances:</h3>
                    <p><strong>Ethereum (ETH):</strong> {{ balance_eth }} ETH</p>
                    <p><strong>Binance Smart Chain (BNB):</strong> {{ balance_bnb }} BNB</p>
                    <p><strong>Polygon (MATIC):</strong> {{ balance_matic }} MATIC</p>
                    <ul>
                        {% for token, balance in token_balances.items %}
                        <li><strong>{{ token }}:</strong> {{ balance }}</li>
                        {% endfor %}
                        <li><strong>USDT (Ethereum):</strong> {{ balance_usdt_eth }} USDT</li>
                        <li><strong>USDT (BSC):</strong> {{ balance_usdt_bnb }} USDT</li>
                        <li><strong>USDT (Polygon):</strong> {{ balance_usdt_matic }} USDT</li>
                    </ul>
                    <div class="buttons-container mt-4 text-center">
                        <button id="buyCryptoButton" class="btn btn-primary wallet-button" onclick="openMoonPayWidget()">Buy Crypto</button>
                        <button class="btn btn-secondary wallet-button" onclick="showModal('selection')">Send</button>
                        <button id="selectChainButton" class="btn btn-secondary wallet-button" onclick="showModal('chainSelection')">Swap Tokens</button>
                    </div>
                    {% elif chain == 'bitcoin' %}
                    <h3>Bitcoin Balance:</h3>
                    <p><strong>Bitcoin (BTC):</strong> {{ balance_btc }} BTC</p>
                    <div class="buttons-container mt-4 text-center">
                        <button class="btn btn-secondary wallet-button" onclick="showModal('btc')">Send Bitcoin</button>
                    </div>
                    {% endif %}
                </div>
            </div>

            <div class="logo">
                <img src="/static/images/Icon_white.png" alt="Logo" class="img-fluid">
            </div>
        </div>

    <!-- section "Settings" & "History Transactions" buttons -->

        <div class="settings-history-section">
            <button id="settingsButton" class="settings-button btn btn-secondary" onclick="openSettings()">Settings</button>
            <button id="historyButton" class="history-button btn btn-secondary" onclick="openHistory()">History Transactions</button>
            <button id="QrCodeButton" class="QrCodeButton-button btn btn-secondary" onclick="QrCodeButton()">Qr-Code</button>
        </div>
    </div>

    <!-- Modals -->
    <!-- Chain Selection Modal -->
    <div id="chainSelectionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('chainSelectionModal')">&times;</span>
            <h3>Select Chain</h3>
            <button id="selectEthChainButton" class="btn btn-secondary my-2 w-100" onclick="showModal('swapEth')">Ethereum</button>
            <button id="selectPolygonChainButton" class="btn btn-secondary my-2 w-100" onclick="showModal('swapPolygon')">Polygon</button>
            <button id="selectBscChainButton" class="btn btn-secondary my-2 w-100" onclick="showModal('swapBsc')">BSC</button>
        </div>
    </div>

   <!-- Selection Modal -->
<div id="selectionModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeModal('selectionModal')">&times;</span>
        <h3 class="mb-4">Select what to send</h3>
        <div class="button-group mb-4">
            <button class="btn btn-secondary mx-2 my-3 w-500" onclick="showModal('eth')">ETH</button>
            <button class="btn btn-secondary mx-2 my-3 w-500" onclick="showModal('bnb')">BNB</button>
            <button class="btn btn-secondary mx-2 my-3 w-500" onclick="showModal('matic')">MATIC</button>
        </div>
        <br class="my-4">
        <div class="button-group">
            <button class="btn btn-secondary mx-2 my-3 w-500" onclick="showModal('usdt_eth')">USDT (Ethereum)</button>
            <button class="btn btn-secondary mx-2 my-3 w-500" onclick="showModal('usdt_bnb')">USDT (BSC)</button>
            <button class="btn btn-secondary mx-2 my-3 w-500" onclick="showModal('usdt_matic')">USDT (Polygon)</button>
        </div>
    </div>
</div>

<!-- Modal window for sending ETH -->
<div id="ethModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h4 class="modal-title">Send ETH</h4>
            <button type="button" class="close" onclick="closeModal('ethModal')">&times;</button>
        </div>
        <div class="modal-body">
            <label for="ethRecipient" class="form-label">Recipient Address:</label>
            <input type="text" id="ethRecipient" class="form-control mb-4">
<br> <br>
            <label for="ethAmount" class="form-label">Amount in ETH:</label>
            <input type="number" id="ethAmount" class="form-control mb-4" oninput="updateUsdEquivalent('eth'); calculateGas('eth'); checkFunds('eth');">
<br> <br>
            <p>Equivalent in USD: <span id="ethUsdEquivalent">0.00</span></p>
            <p>Gas Fee: <span id="ethGasFee">0.00</span> ETH (<span id="ethGasFeeUsd">0.00</span> USD)</p>
            <p>Total with Gas: <span id="ethTotalWithGas">0.00</span> ETH (<span id="ethTotalWithGasUsd">0.00</span> USD)</p>

            <p class="error" id="ethFundsError" style="display:none;">Insufficient funds for the transaction.</p>

            <label for="ethPassword" class="form-label">Enter password:</label>
            <input type="password" id="ethPassword" class="form-control mb-4">
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary" onclick="sendETH()">Send</button>
        </div>
    </div>
</div>

<!-- Modal window for sending BNB -->
<div id="bnbModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h4 class="modal-title">Send BNB</h4>
            <button type="button" class="close" onclick="closeModal('bnbModal')">&times;</button>
        </div>
        <div class="modal-body">
            <label for="bnbRecipient" class="form-label">Recipient Address:</label>
            <input type="text" id="bnbRecipient" class="form-control mb-4"> <br> <br>

            <label for="bnbAmount" class="form-label">Amount in BNB:</label>
            <input type="number" id="bnbAmount" class="form-control mb-4" oninput="updateUsdEquivalent('bnb'); calculateGas('bnb'); checkFunds('bnb');">
<br> <br>
            <p>Equivalent in USD: <span id="bnbUsdEquivalent">0.00</span></p>
            <p>Gas Fee: <span id="bnbGasFee">0.00</span> BNB (<span id="bnbGasFeeUsd">0.00</span> USD)</p>
            <p>Total with Gas: <span id="bnbTotalWithGas">0.00</span> BNB (<span id="bnbTotalWithGasUsd">0.00</span> USD)</p>

            <p class="error" id="bnbFundsError" style="display:none;">Insufficient funds for the transaction.</p>

            <label for="bnbPassword" class="form-label">Enter password:</label>
            <input type="password" id="bnbPassword" class="form-control mb-4">
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary" onclick="sendBNB()">Send</button>
        </div>
    </div>
</div>

<!-- Modal window for sending MATIC -->
<div id="maticModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h4 class="modal-title">Send MATIC</h4>
            <button type="button" class="close" onclick="closeModal('maticModal')">&times;</button>
        </div>
        <div class="modal-body">
            <label for="maticRecipient" class="form-label">Recipient Address:</label>
            <input type="text" id="maticRecipient" class="form-control mb-4">
<br> <br>
            <label for="maticAmount" class="form-label">Amount in MATIC:</label>
            <input type="number" id="maticAmount" class="form-control mb-4" oninput="updateUsdEquivalent('matic'); calculateGas('matic'); checkFunds('matic');">
<br> <br>
            <p>Equivalent in USD: <span id="maticUsdEquivalent">0.00</span></p>
            <p>Gas Fee: <span id="maticGasFee">0.00</span> MATIC (<span id="maticGasFeeUsd">0.00</span> USD)</p>
            <p>Total with Gas: <span id="maticTotalWithGas">0.00</span> MATIC (<span id="maticTotalWithGasUsd">0.00</span> USD)</p>

            <p class="error" id="maticFundsError" style="display:none;">Insufficient funds for the transaction.</p>

            <label for="maticPassword" class="form-label">Enter password:</label>
            <input type="password" id="maticPassword" class="form-control mb-4">
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary" onclick="sendMATIC()">Send</button>
        </div>
    </div>
</div>


<!-- Modal window for sending USDT on Ethereum -->
<div id="usdt_ethModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h4 class="modal-title">Send USDT (Ethereum)</h4>
            <button type="button" class="close" onclick="closeModal('usdt_ethModal')">&times;</button>
        </div>
        <div class="modal-body">
            <label for="usdt_ethRecipient" class="form-label">Recipient Address:</label>
            <input type="text" id="usdt_ethRecipient" class="form-control mb-3">
<br> <br>
            <label for="usdt_ethAmount" class="form-label">Amount in USDT:</label>
            <input type="number" id="usdt_ethAmount" class="form-control mb-3" oninput="calculateUsdtGas('eth');">
<br> <br>
            <p>Gas Fee: <span id="usdt_ethGasFee">0.00</span> ETH (<span id="usdt_ethGasFeeUsd">0.00</span> USD)</p>
            <p>Total with Gas: <span id="usdt_ethTotalWithGas">0.00</span> USDT</p>

            <label for="usdt_ethPassword" class="form-label">Enter password:</label>
            <input type="password" id="usdt_ethPassword" class="form-control mb-3">
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary w-100" onclick="sendUSDT('eth')">Send</button>
        </div>
    </div>
</div>

<!-- Modal window for sending USDT on BSC -->
<div id="usdt_bnbModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h4 class="modal-title">Send USDT (BSC)</h4>
            <button type="button" class="close" onclick="closeModal('usdt_bnbModal')">&times;</button>
        </div>
        <div class="modal-body">
            <label for="usdt_bnbRecipient" class="form-label">Recipient Address:</label>
            <input type="text" id="usdt_bnbRecipient" class="form-control mb-3">
<br> <br>
            <label for="usdt_bnbAmount" class="form-label">Amount in USDT:</label>
            <input type="number" id="usdt_bnbAmount" class="form-control mb-3" oninput="calculateUsdtGas('bnb');">
<br> <br>
            <p>Gas Fee: <span id="usdt_bnbGasFee">0.00</span> BNB (<span id="usdt_bnbGasFeeUsd">0.00</span> USD)</p>
            <p>Total with Gas: <span id="usdt_bnbTotalWithGas">0.00</span> USDT</p>

            <label for="usdt_bnbPassword" class="form-label">Enter password:</label>
            <input type="password" id="usdt_bnbPassword" class="form-control mb-3">
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary w-100" onclick="sendUSDT('bnb')">Send</button>
        </div>
    </div>
</div>

<!-- Modal window for sending USDT on Polygon -->
<div id="usdt_maticModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h4 class="modal-title">Send USDT (Polygon)</h4>
            <button type="button" class="close" onclick="closeModal('usdt_maticModal')">&times;</button>
        </div>
        <div class="modal-body">
            <label for="usdt_maticRecipient" class="form-label">Recipient Address:</label>
            <input type="text" id="usdt_maticRecipient" class="form-control mb-3">
<br> <br>
            <label for="usdt_maticAmount" class="form-label">Amount in USDT:</label>
            <input type="number" id="usdt_maticAmount" class="form-control mb-3" oninput="calculateUsdtGas('matic');">
<br> <br>
            <p>Gas Fee: <span id="usdt_maticGasFee">0.00</span> MATIC (<span id="usdt_maticGasFeeUsd">0.00</span> USD)</p>
            <p>Total with Gas: <span id="usdt_maticTotalWithGas">0.00</span> USDT</p>

            <label for="usdt_maticPassword" class="form-label">Enter password:</label>
            <input type="password" id="usdt_maticPassword" class="form-control mb-3">
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary w-100" onclick="sendUSDT('matic')">Send</button>
        </div>
    </div>
</div>


<!-- Swap Eth Modal -->
<div id="swapEthModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Swap Tokens on Ethereum</h3>
            <button type="button" class="close" onclick="closeModal('swapEthModal')">&times;</button>
        </div>
        <div class="modal-body">
            <div class="token-select-container">
                <label for="from-token-select" class="form-label">From Token:</label>
                <select id="from-token-select" class="select-token form-control">
                    <option value="" disabled selected>Select token</option>
                    <!-- Tokens will be loaded dynamically -->
                </select>
            </div>
            <div class="mb-4">
                <label for="from-amount" class="form-label">Enter Amount:</label>
                <input type="number" id="from-amount" class="form-control" placeholder="Enter amount">
            </div>
            <br>
            <div class="token-select-container">
                <label for="to-token-select" class="form-label">To Token:</label>
                <select id="to-token-select" class="select-token form-control">
                    <option value="" disabled selected>Select token</option>
                    <!-- Tokens will be loaded dynamically -->
                </select>
            </div>
            <div class="mt-4">
                <label for="swapEthPassword" class="form-label">Enter password:</label>
                <input type="password" id="swapEthPassword" class="form-control mb-3">
            </div>
        </div>
        <div class="modal-footer">
            <button id="confirmSwapEthButton" class="btn btn-primary w-100" onclick="confirmSwap('eth')">Swap</button>
        </div>
    </div>
</div>

<!-- Swap Modal for Polygon -->
<div id="swapPolygonModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h4 class="modal-title">Swap Tokens on Polygon</h4>
            <button type="button" class="close" onclick="closeModal('swapPolygonModal')">&times;</button>
        </div>
        <div class="modal-body">
            <div class="token-select-container">
                <label for="from-token-select-polygon" class="form-label">From Token:</label>
                <select id="from-token-select-polygon" class="select-token form-control">
                    <option value="" disabled selected>Select token</option>
                    <!-- Tokens will be loaded dynamically -->
                </select>
            </div>
            <div class="mb-4">
                <label for="from-amount-polygon" class="form-label">Enter Amount:</label>
                <input type="number" id="from-amount-polygon" class="form-control" placeholder="Enter amount">
            </div>
            <br>
            <div class="token-select-container">
                <label for="to-token-select-polygon" class="form-label">To Token:</label>
                <select id="to-token-select-polygon" class="select-token form-control">
                    <option value="" disabled selected>Select token</option>
                    <!-- Tokens will be loaded dynamically -->
                </select>
            </div>
            <div class="mt-4">
                <label for="swapPolygonPassword" class="form-label">Enter password:</label>
                <input type="password" id="swapPolygonPassword" class="form-control mb-3">
            </div>
        </div>
        <div class="modal-footer">
            <button id="confirmSwapPolygonButton" class="btn btn-primary w-100" onclick="confirmSwap('polygon')">Swap</button>
        </div>
    </div>
</div>

<!-- Swap Modal for BSC -->
<div id="swapBscModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h4 class="modal-title">Swap Tokens on BSC</h4>
            <button type="button" class="close" onclick="closeModal('swapBscModal')">&times;</button>
        </div>
        <div class="modal-body">
            <div class="token-select-container">
                <label for="from-token-select-bsc" class="form-label">From Token:</label>
                <select id="from-token-select-bsc" class="select-token form-control">
                    <option value="" disabled selected>Select token</option>
                    <!-- Tokens will be loaded dynamically -->
                </select>
            </div>
            <div class="mb-4">
                <label for="from-amount-bsc" class="form-label">Enter Amount:</label>
                <input type="number" id="from-amount-bsc" class="form-control" placeholder="Enter amount">
            </div>
            <br>
            <div class="token-select-container">
                <label for="to-token-select-bsc" class="form-label">To Token:</label>
                <select id="to-token-select-bsc" class="select-token form-control">
                    <option value="" disabled selected>Select token</option>
                    <!-- Tokens will be loaded dynamically -->
                </select>
            </div>
            <div class="mt-4">
                <label for="swapBscPassword" class="form-label">Enter password:</label>
                <input type="password" id="swapBscPassword" class="form-control mb-3">
            </div>
        </div>
        <div class="modal-footer">
            <button id="confirmSwapBscButton" class="btn btn-primary w-100" onclick="confirmSwap('bsc')">Swap</button>
        </div>
    </div>
</div>


    <!-- Modal window for sending BTC -->
<div id="btcModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Send BTC</h3>
            <button type="button" class="close" onclick="closeModal('btcModal')">&times;</button>
        </div>
        <div class="modal-body">
            <label for="btcRecipient" class="form-label">Recipient Address:</label>
            <input type="text" id="btcRecipient" class="form-control mb-3">
            <br><br>
            <label for="btcAmount" class="form-label">Amount in BTC:</label>
            <input type="number" id="btcAmount" class="form-control mb-3">
            <br><br>
            <label for="btcPassword" class="form-label">Enter password:</label>
            <input type="password" id="btcPassword" class="form-control mb-3">
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary w-100" onclick="sendBTC()">Send</button>
        </div>
    </div>
</div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@uniswap/sdk@3.0.3/dist/uniswap-sdk.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>


    <script>
        const address = '{{ address }}';
        const encryptedKey = localStorage.getItem('encryptedKey');

        const chain = '{{ chain }}';

        const RPC_URLS = {
            eth: 'https://mainnet.infura.io/v3/a4c60cf1bd7e4c288d9221144f9efbe2',
            bnb: 'https://bsc-dataseed.binance.org/',
            matic: 'https://polygon-rpc.com'
        };

        const USDT_CONTRACT_ADDRESSES = {
            eth: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
            bnb: '0x55d398326f99059fF775485246999027B3197955',
            matic: '0x3813e82e6f7098b9583FC0F33a962D02018B6803'
        };

        let ethToUsdRate = 0;
        let bnbToUsdRate = 0;
        let maticToUsdRate = 0;
        let gasPrice = 0;
        let gasLimit = 21000; // Typically 21000 for ETH transfer
        let ethBalance = parseFloat('{{ balance_eth }}'); // Assuming the balance is passed from the server
        let bnbBalance = parseFloat('{{ balance_bnb }}'); // Assuming the balance is passed from the server
        let maticBalance = parseFloat('{{ balance_matic }}'); // Assuming the balance is passed from the server


        async function fetchUsdRates() {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum,binancecoin,matic-network&vs_currencies=usd');
                const data = await response.json();
                ethToUsdRate = data.ethereum.usd;
                bnbToUsdRate = data.binancecoin.usd;
                maticToUsdRate = data['matic-network'].usd;
            } catch (error) {
                console.error('Error fetching USD rates:', error);
            }
        }

        async function fetchGasPrice(chain) {
    try {
        const provider = new ethers.providers.JsonRpcProvider(RPC_URLS[chain]);
        gasPrice = await provider.getGasPrice();
        gasPrice = parseFloat(ethers.utils.formatUnits(gasPrice, 'gwei'));
        if (chain === 'eth' || chain === 'bnb' || chain === 'matic') {
            calculateGas(chain);
        }
    } catch (error) {
        console.error('Error fetching gas price:', error);
    }
}

        function calculateGas(chain) {
            const amount = document.getElementById(chain + 'Amount').value;
            const gasFeeElement = document.getElementById(chain + 'GasFee');
            const gasFeeUsdElement = document.getElementById(chain + 'GasFeeUsd');
            const totalWithGasElement = document.getElementById(chain + 'TotalWithGas');
            const totalWithGasUsdElement = document.getElementById(chain + 'TotalWithGasUsd');
            const amountNumber = parseFloat(amount);
            const usdRate = chain === 'eth' ? ethToUsdRate : chain === 'bnb' ? bnbToUsdRate : maticToUsdRate;


            if (!isNaN(amountNumber) && amountNumber > 0) {
                const gasFee = (gasPrice * gasLimit) / 1e9; // Convert gas fee to respective currency

                const totalWithGas = amountNumber + gasFee;
                const gasFeeUsd = gasFee * usdRate;

                const totalWithGasUsd = totalWithGas * usdRate;

                gasFeeElement.textContent = gasFee.toFixed(4);
                gasFeeUsdElement.textContent = gasFeeUsd.toFixed(4); // Change to 4 decimal places
                totalWithGasElement.textContent = totalWithGas.toFixed(6);
                totalWithGasUsdElement.textContent = totalWithGasUsd.toFixed(2);

            } else {
                gasFeeElement.textContent = '0.00';
                gasFeeUsdElement.textContent = '0.00';
                totalWithGasElement.textContent = '0.00';
                totalWithGasUsdElement.textContent = '0.00';
            }
        }

        function calculateUsdtGas(chain) {
            const amount = document.getElementById(`usdt_${chain}Amount`).value;
            const gasFeeElement = document.getElementById(`usdt_${chain}GasFee`);
            const gasFeeUsdElement = document.getElementById(`usdt_${chain}GasFeeUsd`);
            const totalWithGasElement = document.getElementById(`usdt_${chain}TotalWithGas`);
            const amountNumber = parseFloat(amount);
            const usdRate = chain === 'eth' ? ethToUsdRate : chain === 'bnb' ? bnbToUsdRate : maticToUsdRate;


            if (!isNaN(amountNumber) && amountNumber > 0) {
                const gasFee = (gasPrice * gasLimit) / 1e9; // Convert gas fee to respective currency
                console.log('Gas Fee:', gasFee);

                const gasFeeUsd = gasFee * usdRate;
                console.log('Gas Fee in USD:', gasFeeUsd);

                gasFeeElement.textContent = gasFee.toFixed(6);
                gasFeeUsdElement.textContent = gasFeeUsd.toFixed(6);

                totalWithGasElement.textContent = (amountNumber + gasFee).toFixed(6);

                console.log('Updated Gas Fee Element:', gasFeeElement.textContent);
                console.log('Updated Gas Fee USD Element:', gasFeeUsdElement.textContent);
            } else {
                gasFeeElement.textContent = '0.00';
                gasFeeUsdElement.textContent = '0.00';
                totalWithGasElement.textContent = '0.00';
            }
        }

        function checkFunds(chain) {
            const amount = document.getElementById(chain + 'Amount').value;
            const amountNumber = parseFloat(amount);
            const totalWithGas = parseFloat(document.getElementById(chain + 'TotalWithGas').textContent);
            const fundsError = document.getElementById(chain + 'FundsError');

            const balance = chain === 'eth' ? ethBalance : chain === 'bnb' ? bnbBalance : maticBalance;

            if (!isNaN(amountNumber) && amountNumber > 0) {
                if (balance < totalWithGas) {
                    fundsError.style.display = 'block';
                } else {
                    fundsError.style.display = 'none';
                }
            } else {
                fundsError.style.display = 'none';
            }
        }

        function showSelectionModal() {
            const modal = document.getElementById('selectionModal');
            modal.style.display = 'block';
        }

        function showModal(type) {
    closeModal('selection'); // Закрыть окно выбора перед показом нового окна

    const modal = document.getElementById(type + 'Modal');
    if (modal) {
        modal.style.display = 'block'; // Показать модальное окно
    } else {
        console.error("Modal with id " + type + " not found");
    }

    // Если модальное окно связано с цепочками (ETH, BNB, MATIC или USDT)
    if (type === 'eth' || type === 'bnb' || type === 'matic' || type.startsWith('usdt')) {
        fetchUsdRates().then(() => {
            fetchGasPrice(type.replace('usdt_', '')).then(() => {
                console.log('Gas price fetched and modal shown for:', type);
                if (type.startsWith('usdt')) {
                    calculateUsdtGas(type.replace('usdt_', ''));
                } else {
                    calculateGas(type);
                }
            });
        });
    }
}

        function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = 'none'; // Скрыть модальное окно
    } else {
        console.error("Modal with id " + modalId + " not found");
    }
}

// Закрытие модального окна при клике на его область
window.onclick = function(event) {
    if (event.target.classList.contains('modal')) {
        event.target.style.display = "none";
    }
};


        document.addEventListener('DOMContentLoaded', (event) => {
            fetchUsdRates(); // Fetch the USD rates when the page loads
            fetchGasPrice('eth');
            fetchGasPrice('bnb');
            fetchGasPrice('matic'); // Fetch the Gas Price when the page loads
        });

        function updateUsdEquivalent(chain) {
            const amount = document.getElementById(chain + 'Amount').value;
            const usdEquivalentElement = document.getElementById(chain + 'UsdEquivalent');
            const amountNumber = parseFloat(amount);
            const usdRate = chain === 'eth' ? ethToUsdRate : chain === 'bnb' ? bnbToUsdRate : maticToUsdRate;

            if (!isNaN(amountNumber) && amountNumber > 0) {
                const usdValue = (amountNumber * usdRate).toFixed(2);
                usdEquivalentElement.textContent = usdValue;
            } else {
                usdEquivalentElement.textContent = '0.00';
            }
        }

        async function sendETH() {
            const recipient = document.getElementById('ethRecipient').value;
            const amount = document.getElementById('ethAmount').value;
            const password = document.getElementById('ethPassword').value;

            if (!recipient || !amount || !password) {
                alert('Please enter recipient address, amount, and password.');
                return;
            }

            try {
                // Fetch the latest gas price before sending the transaction
                await fetchGasPrice('eth');

                let decryptedPrivateKey;
                try {
                    decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
                    if (!decryptedPrivateKey) {
                        throw new Error("Decryption failed");
                    }
                } catch (decryptionError) {
                    console.error("Decryption error:", decryptionError);
                    alert('Error decrypting the private key. Please check your password and try again.');
                    return;
                }

                const provider = new ethers.providers.JsonRpcProvider(RPC_URLS['eth']); // Using RPC URL for the Ethereum network
                const wallet = new ethers.Wallet(decryptedPrivateKey, provider);

                const gasPriceWei = ethers.utils.parseUnits(gasPrice.toString(), 'gwei');
                const tx = {
                    to: recipient,
                    value: ethers.utils.parseEther(amount),
                    gasPrice: gasPriceWei,
                    gasLimit: gasLimit
                };

                const balance = await wallet.getBalance();
                const totalCost = tx.value.add(gasPriceWei.mul(gasLimit));
                if (balance.lt(totalCost)) {
                    alert('Insufficient funds for the transaction.');
                    return;
                }

                const transactionResponse = await wallet.sendTransaction(tx);
                alert('Transaction sent: ' + transactionResponse.hash);
                closeModal('eth');
            } catch (error) {
                console.error("Error sending ETH:", error);
                alert('Error sending ETH: ' + error.message);
            }
        }

        async function sendBNB() {
            const recipient = document.getElementById('bnbRecipient').value;
            const amount = document.getElementById('bnbAmount').value;
            const password = document.getElementById('bnbPassword').value;

            if (!recipient || !amount || !password) {
                alert('Please enter recipient address, amount, and password.');
                return;
            }

            try {
                // Fetch the latest gas price before sending the transaction
                await fetchGasPrice('bnb');

                let decryptedPrivateKey;
                try {
                    decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
                    if (!decryptedPrivateKey) {
                        throw new Error("Decryption failed");
                    }
                } catch (decryptionError) {
                    console.error("Decryption error:", decryptionError);
                    alert('Error decrypting the private key. Please check your password and try again.');
                    return;
                }

                const provider = new ethers.providers.JsonRpcProvider(RPC_URLS['bnb']); // Using RPC URL for the BSC network
                const wallet = new ethers.Wallet(decryptedPrivateKey, provider);

                const gasPriceWei = ethers.utils.parseUnits(gasPrice.toString(), 'gwei');
                const tx = {
                    to: recipient,
                    value: ethers.utils.parseEther(amount),
                    gasPrice: gasPriceWei,
                    gasLimit: gasLimit
                };

                const balance = await wallet.getBalance();
                const totalCost = tx.value.add(gasPriceWei.mul(gasLimit));
                if (balance.lt(totalCost)) {
                    alert('Insufficient funds for the transaction.');
                    return;
                }

                const transactionResponse = await wallet.sendTransaction(tx);
                alert('Transaction sent: ' + transactionResponse.hash);
                closeModal('bnb');
            } catch (error) {
                console.error("Error sending BNB:", error);
                alert('Error sending BNB: ' + error.message);
            }
        }

        async function sendMATIC() {
            const recipient = document.getElementById('maticRecipient').value;
            const amount = document.getElementById('maticAmount').value;
            const password = document.getElementById('maticPassword').value;

            if (!recipient || !amount || !password) {
                alert('Please enter recipient address, amount, and password.');
                return;
            }

            try {
                // Fetch the latest gas price before sending the transaction
                await fetchGasPrice('matic');

                let decryptedPrivateKey;
                try {
                    decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
                    if (!decryptedPrivateKey) {
                        throw new Error("Decryption failed");
                    }
                } catch (decryptionError) {
                    console.error("Decryption error:", decryptionError);
                    alert('Error decrypting the private key. Please check your password and try again.');
                    return;
                }

                const provider = new ethers.providers.JsonRpcProvider(RPC_URLS['matic']); // Using RPC URL for the Polygon network
                const wallet = new ethers.Wallet(decryptedPrivateKey, provider);

                const gasPriceWei = ethers.utils.parseUnits(gasPrice.toString(), 'gwei');
                const tx = {
                    to: recipient,
                    value: ethers.utils.parseEther(amount),
                    gasPrice: gasPriceWei,
                    gasLimit: gasLimit
                };

                const balance = await wallet.getBalance();
                const totalCost = tx.value.add(gasPriceWei.mul(gasLimit));
                if (balance.lt(totalCost)) {
                    alert('Insufficient funds for the transaction.');
                    return;
                }

                const transactionResponse = await wallet.sendTransaction(tx);
                alert('Transaction sent: ' + transactionResponse.hash);
                closeModal('matic');
            } catch (error) {
                console.error("Error sending MATIC:", error);
                alert('Error sending MATIC: ' + error.message);
            }
        }

        async function sendUSDT(chain) {
            const recipient = document.getElementById(`usdt_${chain}Recipient`).value;
            const amount = document.getElementById(`usdt_${chain}Amount`).value;
            const password = document.getElementById(`usdt_${chain}Password`).value;

            if (!recipient || !amount || !password) {
                alert('Please enter recipient address, amount, and password.');
                return;
            }

            try {
                let decryptedPrivateKey;
                try {
                    decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
                    if (!decryptedPrivateKey) {
                        throw new Error("Decryption failed");
                    }
                } catch (decryptionError) {
                    console.error("Decryption error:", decryptionError);
                    alert('Error decrypting the private key. Please check your password and try again.');
                    return;
                }

                const provider = new ethers.providers.JsonRpcProvider(RPC_URLS[chain]); // Using RPC URL for the respective network
                const wallet = new ethers.Wallet(decryptedPrivateKey, provider);

                const usdtContractAddress = USDT_CONTRACT_ADDRESSES[chain];
                const usdtAbi = [
                    "function transfer(address to, uint amount) returns (bool)"
                ];
                const contract = new ethers.Contract(usdtContractAddress, usdtAbi, wallet);
                const gasPriceWei = ethers.utils.parseUnits(gasPrice.toString(), 'gwei');
                const tx = await contract.populateTransaction.transfer(recipient, ethers.utils.parseUnits(amount, 6), {
            gasPrice: gasPriceWei,
            gasLimit: 60000 // Typically higher gas limit for token transfers
        });


        const balance = await wallet.getBalance();
        const totalCost = ethers.BigNumber.from(tx.value || 0).add(gasPriceWei.mul(60000));
        if (balance.lt(totalCost)) {
            alert('Insufficient funds for the transaction.');
            return;
        }

        const transactionResponse = await wallet.sendTransaction(tx);
        alert('Transaction sent: ' + transactionResponse.hash);
        closeModal(`usdt_${chain}`);
            } catch (error) {
                console.error(`Error sending USDT (${chain}):`, error);
                alert(`Error sending USDT (${chain}): ${error.message}`);
            }
        }

    </script>

<script type="module">
      import { loadMoonPay } from 'https://cdn.jsdelivr.net/npm/@moonpay/moonpay-js';
      async function initializeMoonPay() {
        const moonPay = await loadMoonPay();

        window.openMoonPayWidget = () => {
          const widget = moonPay({
            flow: 'buy',
            environment: 'sandbox', // Use 'production' for combat mode
            params: {
              apiKey: 'pk_test_JdA1m8QXY9I6CI0FRfrihIUKeQ0' // test API key
            },
            variant: 'overlay',
            handlers: {
              onTransactionCompleted: (data) => {
                console.log('Purchase successful:', data);
              },
              onTransactionFailed: (error) => {
                console.error('Purchase failed:', error);
              }
            }
          });

          widget.show();
        };
      }

      initializeMoonPay();
    </script>

<script type="module">
    import { ChainId, Token, WETH, Fetcher, Route, Trade, TokenAmount, TradeType, Percent } from 'https://jspm.dev/@uniswap/sdk@3.0.3';

    const ethTokenListURL = 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/tokenlist.json';
    const polygonTokenListURL = 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/polygon/tokenlist.json';
    const bscTokenListURL = 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/smartchain/tokenlist.json';

    async function fetchTokenList(tokenListURL, fromTokenSelectId, toTokenSelectId, defaultToken) {
        try {
            const response = await fetch(tokenListURL);
            const data = await response.json();
            let tokens = data.tokens;

            if (!tokens || tokens.length === 0) {
                return;
            }


            tokens.unshift(defaultToken); // Add the default token (e.g., ETH, BNB, MATIC) to the beginning of the list

            const fromTokenSelect = document.getElementById(fromTokenSelectId);
            const toTokenSelect = document.getElementById(toTokenSelectId);

            tokens.forEach(token => {
                const option = document.createElement('option');
                option.value = token.address;
                option.text = `${token.symbol} (${token.name})`;
                fromTokenSelect.appendChild(option);
                toTokenSelect.appendChild(option.cloneNode(true));
            });

        } catch (error) {
            console.error('Error fetching token list:', error);
        }
    }

    function setupEventListeners() {
    // Button to open the network selection window
    document.getElementById('selectChainButton').addEventListener('click', function() {
        document.getElementById('chainSelectionModal').style.display = 'block';
    });

    // Buttons for selecting a network and opening the corresponding swap window
    document.getElementById('selectEthChainButton').addEventListener('click', function() {
        closeModal('chainSelectionModal');
        document.getElementById('swapEthModal').style.display = 'block';
    });

    document.getElementById('selectPolygonChainButton').addEventListener('click', function() {
        closeModal('chainSelectionModal');
        document.getElementById('swapPolygonModal').style.display = 'block';
    });

    document.getElementById('selectBscChainButton').addEventListener('click', function() {
        closeModal('chainSelectionModal');
        document.getElementById('swapBscModal').style.display = 'block';
    });

    // Buttons to confirm the swap in each of the modal windows
    document.getElementById('confirmSwapEthButton').addEventListener('click', swapEthTokens);
    document.getElementById('confirmSwapPolygonButton').addEventListener('click', swapTokensOnPolygon);
    document.getElementById('confirmSwapBscButton').addEventListener('click', swapTokensOnBSC);

    // Close the modal window when clicking outside of it
    window.onclick = function(event) {
        if (event.target.className === 'modal') {
            event.target.style.display = "none";
        }
    };
}

    async function swapEthTokens() {
        const fromTokenAddress = document.getElementById('from-token-select').value;
        const toTokenAddress = document.getElementById('to-token-select').value;
        const amount = document.getElementById('from-amount').value;

        const provider = new ethers.providers.JsonRpcProvider('https://mainnet.infura.io/v3/a4c60cf1bd7e4c288d9221144f9efbe2');

        const password = document.getElementById('swapEthPassword').value;


        let decryptedPrivateKey;
        try {
            decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
            if (!decryptedPrivateKey) {
                throw new Error("Error decrypting private key");
            }
        } catch (error) {
            console.error("Error decrypting private key:", error);
            alert('Error decrypting private key. Please, enter the correct password and try again.');
            return;
        }

        const wallet = new ethers.Wallet(decryptedPrivateKey, provider);
        const signer = wallet;

        const chainId = ChainId.MAINNET;

        let fromToken, toToken, pair;

        if (fromTokenAddress === 'ETH') {
            fromToken = WETH[chainId];
            toToken = await Fetcher.fetchTokenData(chainId, toTokenAddress, provider);
            pair = await Fetcher.fetchPairData(toToken, WETH[chainId], provider);
        } else if (toTokenAddress === 'ETH') {
            fromToken = await Fetcher.fetchTokenData(chainId, fromTokenAddress, provider);
            toToken = WETH[chainId];
            pair = await Fetcher.fetchPairData(fromToken, WETH[chainId], provider);
        } else {
            fromToken = await Fetcher.fetchTokenData(chainId, fromTokenAddress, provider);
            toToken = await Fetcher.fetchTokenData(chainId, toTokenAddress, provider);
            pair = await Fetcher.fetchPairData(fromToken, toToken, provider);
        }

        const route = new Route([pair], fromToken);
        const trade = new Trade(route, new TokenAmount(fromToken, ethers.utils.parseUnits(amount, fromToken.decimals)), TradeType.EXACT_INPUT);

        const slippageTolerance = new Percent('50', '10000'); // 0.50%
        const amountOutMin = trade.minimumAmountOut(slippageTolerance).raw.toString();
        const path = fromTokenAddress === 'ETH' ? [WETH[chainId].address, toToken.address] :
                      toTokenAddress === 'ETH' ? [fromToken.address, WETH[chainId].address] :
                      [fromToken.address, toToken.address];
        const to = await signer.getAddress();
        const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes from current Unix time

        const value = fromTokenAddress === 'ETH' ? ethers.utils.parseUnits(amount, 'ether') : ethers.utils.parseUnits(amount, fromToken.decimals);
        const uniswapRouterAddress = '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D'; // Router address Uniswap V2
        const uniswapRouterAbi = [
            "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)",
            "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) payable",
            "function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)"
        ];
        const uniswapRouter = new ethers.Contract(uniswapRouterAddress, uniswapRouterAbi, signer);

        if (fromTokenAddress !== 'ETH') {
            const erc20Abi = ["function approve(address spender, uint256 amount) public returns (bool)"];
            const erc20Contract = new ethers.Contract(fromTokenAddress, erc20Abi, signer);
            const txApprove = await erc20Contract.approve(uniswapRouterAddress, value);
            await txApprove.wait();
        }

        const balance = await wallet.getBalance();
        const gasPrice = await provider.getGasPrice();
        const gasLimit = ethers.BigNumber.from(210000); // Possibly need to adjust

        const totalCost = fromTokenAddress === 'ETH' ? value.add(gasPrice.mul(gasLimit)) : gasPrice.mul(gasLimit);

        if (balance.lt(totalCost)) {
            alert('Insufficient funds to complete the transaction.');
            return;
        }

        let tx;
        if (fromTokenAddress === 'ETH') {
            tx = await uniswapRouter.swapExactETHForTokens(
                ethers.BigNumber.from(amountOutMin),
                path,
                to,
                deadline,
                {
                    value: value,
                    gasPrice: gasPrice,
                    gasLimit: gasLimit
                }
            );
        } else if (toTokenAddress === 'ETH') {
            tx = await uniswapRouter.swapExactTokensForETH(
                ethers.BigNumber.from(value),
                ethers.BigNumber.from(amountOutMin),
                path,
                to,
                deadline,
                {
                    gasPrice: gasPrice,
                    gasLimit: gasLimit
                }
            );
        } else {
            tx = await uniswapRouter.swapExactTokensForTokens(
                ethers.BigNumber.from(value),
                ethers.BigNumber.from(amountOutMin),
                path,
                to,
                deadline,
                {
                    gasPrice: gasPrice,
                    gasLimit: gasLimit
                }
            );
        }
        alert('Swap transaction successfully: ' + tx.hash);
        closeModal('swapEthModal');
    }

    async function swapTokensOnPolygon() {
    const fromTokenAddress = document.getElementById('from-token-select-polygon').value;
    const toTokenAddress = document.getElementById('to-token-select-polygon').value;
    const amount = document.getElementById('from-amount-polygon').value;

    const provider = new ethers.providers.JsonRpcProvider(RPC_URLS['matic']);

    const password = document.getElementById('swapPolygonPassword').value;

    let decryptedPrivateKey;
    try {
        decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
        if (!decryptedPrivateKey) {
            throw new Error("Error decrypting private key");
        }
    } catch (error) {
        console.error("Error decrypting private key:", error);
        alert('Error decrypting private key. Try again.');
        return;
    }

    const wallet = new ethers.Wallet(decryptedPrivateKey, provider);
    const signer = wallet;

    const uniswapRouterAddress = '0x1b02da8cb0d097eb8d57a175b88c7d8b47997506'; // Sushiswap Router (Uniswap V2 Fork) for Polygon
    const uniswapRouterAbi = [
        "function swapExactTokensForTokens(uint256,uint256,address[],address,uint256) external returns (uint256[])",
        "function swapExactETHForTokens(uint256,address[],address,uint256) external payable returns (uint256[])",
        "function swapExactTokensForETH(uint256,uint256,address[],address,uint256) external returns (uint256[])"
    ];

    const uniswapRouter = new ethers.Contract(uniswapRouterAddress, uniswapRouterAbi, signer);

    const path = fromTokenAddress === 'MATIC' ? ['0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619', toTokenAddress] :
                  toTokenAddress === 'MATIC' ? [fromTokenAddress, '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619'] :
                  [fromTokenAddress, toTokenAddress];

    const to = await signer.getAddress();
    const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes from current Unix time

    const value = fromTokenAddress === 'MATIC' ? ethers.utils.parseUnits(amount, 'ether') : undefined;

    const gasPrice = await provider.getGasPrice();
    const gasLimit = ethers.BigNumber.from(210000);

    // Checking your balance before sending a transaction
    const balance = await wallet.getBalance();
    const totalCost = gasPrice.mul(gasLimit).add(value || 0);

    if (balance.lt(totalCost)) {
        alert("Insufficient funds to complete the transaction.");
        return;
    }

    if (fromTokenAddress !== 'MATIC') {
        const erc20Abi = ["function approve(address spender, uint256 amount) public returns (bool)"];
        const erc20Contract = new ethers.Contract(fromTokenAddress, erc20Abi, signer);
        const txApprove = await erc20Contract.approve(uniswapRouterAddress, ethers.utils.parseUnits(amount, 18));
        await txApprove.wait();
    }

    let tx;
    if (fromTokenAddress === 'MATIC') {
        tx = await uniswapRouter.swapExactETHForTokens(
            0, // minimum amount of tokens to receive
            path,
            to,
            deadline,
            {
                value: ethers.utils.parseUnits(amount, 'ether'),
                gasPrice: gasPrice,
                gasLimit: gasLimit
            }
        );
    } else if (toTokenAddress === 'MATIC') {
        tx = await uniswapRouter.swapExactTokensForETH(
            ethers.utils.parseUnits(amount, 18),
            0, // minimum amount of eth to receive
            path,
            to,
            deadline,
            {
                gasPrice: gasPrice,
                gasLimit: gasLimit
            }
        );
    } else {
        tx = await uniswapRouter.swapExactTokensForTokens(
            ethers.utils.parseUnits(amount, 18),
            0, // minimum amount of tokens to receive
            path,
            to,
            deadline,
            {
                gasPrice: gasPrice,
                gasLimit: gasLimit
            }
        );
    }

    alert('Swap transaction completed successfully: ' + tx.hash);
    closeModal('swapPolygon');
}

    async function swapTokensOnBSC() {
        const fromTokenAddress = document.getElementById('from-token-select-bsc').value;
        const toTokenAddress = document.getElementById('to-token-select-bsc').value;
        const amount = document.getElementById('from-amount-bsc').value;

        if (!fromTokenAddress || !toTokenAddress || !amount) {
            alert('Please fill in all fields.');
            return;
        }

        const pancakeRouterAddress = '0x10ED43C718714eb63d5aA57B78B54704E256024E'; // PancakeSwap Router on BSC
        const pancakeRouterAbi = [
            "function swapExactTokensForTokens(uint256,uint256,address[],address,uint256) external returns (uint256[])",
            "function swapExactETHForTokens(uint256,address[],address,uint256) external payable returns (uint256[])",
            "function swapExactTokensForETH(uint256,uint256,address[],address,uint256) external returns (uint256[])"
        ];

        const RPC_URLS = {
            bsc: 'https://bsc-dataseed.binance.org/'
        };

        const provider = new ethers.providers.JsonRpcProvider(RPC_URLS['bsc']);

        const password = document.getElementById('swapBscPassword').value;

        let decryptedPrivateKey;
        try {
            decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
            if (!decryptedPrivateKey) {
                throw new Error("Error decrypting private key");
            }
        } catch (error) {
            console.error("Error decrypting private key:", error);
            alert('Error decrypting private key. Try again.');
            return;
        }

        const wallet = new ethers.Wallet(decryptedPrivateKey, provider);
        const signer = wallet;

        const pancakeRouter = new ethers.Contract(pancakeRouterAddress, pancakeRouterAbi, signer);

        const path = fromTokenAddress === 'BNB' ? [ethers.constants.AddressZero, toTokenAddress] :
                      toTokenAddress === 'BNB' ? [fromTokenAddress, ethers.constants.AddressZero] :
                      [fromTokenAddress, toTokenAddress];

        const to = await signer.getAddress();
        const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes from current Unix time

        const value = fromTokenAddress === 'BNB' ? ethers.utils.parseUnits(amount, 'ether') : undefined;

        if (fromTokenAddress !== 'BNB') {
            const erc20Abi = ["function approve(address spender, uint256 amount) public returns (bool)"];
            const erc20Contract = new ethers.Contract(fromTokenAddress, erc20Abi, signer);
            const txApprove = await erc20Contract.approve(pancakeRouterAddress, ethers.utils.parseUnits(amount, 18));
            await txApprove.wait();
        }

        const gasPrice = await provider.getGasPrice();
        const gasLimit = ethers.BigNumber.from(210000);

        // Checking your balance before sending a transaction
        const balance = await wallet.getBalance();
        const totalCost = gasPrice.mul(gasLimit).add(value || 0);

        if (balance.lt(totalCost)) {
            alert("Insufficient funds to complete the transaction.");
            return;
        }

        let tx;
        if (fromTokenAddress === 'BNB') {
            tx = await pancakeRouter.swapExactETHForTokens(
                0, // minimum amount of tokens to receive
                path,
                to,
                deadline,
                {
                    value: ethers.utils.parseUnits(amount, 'ether'),
                    gasPrice: gasPrice,
                    gasLimit: gasLimit
                }
            );
        } else if (toTokenAddress === 'BNB') {
            tx = await pancakeRouter.swapExactTokensForETH(
                ethers.utils.parseUnits(amount, 18),
                0, // minimum amount of bnb to receive
                path,
                to,
                deadline,
                {
                    gasPrice: gasPrice,
                    gasLimit: gasLimit
                }
            );
        } else {
            tx = await pancakeRouter.swapExactTokensForTokens(
                ethers.utils.parseUnits(amount, 18),
                0, // // minimum amount of tokens to receive
                path,
                to,
                deadline,
                {
                    gasPrice: gasPrice,
                    gasLimit: gasLimit
                }
            );
        }

        alert('Swap transaction completed successfully: ' + tx.hash);
        closeModal('swapBsc');
    }

    document.addEventListener('DOMContentLoaded', () => {
        fetchTokenList(ethTokenListURL, 'from-token-select', 'to-token-select', {
            address: 'ETH',
            symbol: 'ETH',
            name: 'Ethereum',
            decimals: 18
        });

        fetchTokenList(polygonTokenListURL, 'from-token-select-polygon', 'to-token-select-polygon', {
            address: 'MATIC',
            symbol: 'MATIC',
            name: 'Polygon',
            decimals: 18
        });

        fetchTokenList(bscTokenListURL, 'from-token-select-bsc', 'to-token-select-bsc', {
            address: 'BNB',
            symbol: 'BNB',
            name: 'Binance Coin',
            decimals: 18
        });

        setupEventListeners();
    });
</script>

    <script src="/static/js/bundle.js"></script>
    <script src="/static/js/bitcoinjs-lib.js"></script>
</body>
</html>