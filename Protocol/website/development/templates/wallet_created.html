<!DOCTYPE html>
<html>
<head>
    <title>Wallet Created</title>
    <style>
        .buttons-container {
            margin-top: 20px;
        }
        .wallet-button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgb(0,0,0);
            background-color: rgba(0,0,0,0.4);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .error {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h2>Wallet Created Successfully</h2>
    <p><strong>Address:</strong> {{ address }}</p>
    <h3>Balances:</h3>
    <p><strong>Ethereum (ETH):</strong> {{ balance_eth }} ETH</p>
    <p><strong>Binance Smart Chain (BNB):</strong> {{ balance_bnb }} BNB</p>
    <p><strong>Polygon (MATIC):</strong> {{ balance_matic }} MATIC</p>
    <ul>
    {% for token, balance in token_balances.items %}
        <li><strong>{{ token }}:</strong> {{ balance }}</li>
    {% endfor %}
    <li><strong>USDT (Ethereum):</strong> {{ balance_usdt_eth }} USDT</li>
    <li><strong>USDT (BSC):</strong> {{ balance_usdt_bnb }} USDT</li>
    <li><strong>USDT (Polygon):</strong> {{ balance_usdt_matic }} USDT</li>
    </ul>
    <div class="buttons-container">
        <button id="buyCryptoButton" class="wallet-button" onclick="openMoonPayWidget()">Buy Crypto</button>
        <button class="wallet-button" onclick="showSelectionModal()">Send</button>
        <button id="swapButton" class="wallet-button">Swap Tokens</button>
        <button id="swapPolygonButton" class="wallet-button">Swap Tokens on Polygon</button>
        <button id="swapBscButton" class="wallet-button">Swap Tokens on BSC</button>
    </div>

    <!-- Selection Modal -->
    <div id="selectionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('selectionModal')">&times;</span>
            <h2>Select what to send</h2>
            <button class="wallet-button" onclick="showModal('eth')">ETH</button>
            <button class="wallet-button" onclick="showModal('bnb')">BNB</button>
            <button class="wallet-button" onclick="showModal('matic')">MATIC</button>
            <button class="wallet-button" onclick="showModal('usdt_eth')">USDT (Ethereum)</button>
            <button class="wallet-button" onclick="showModal('usdt_bnb')">USDT (BSC)</button>
            <button class="wallet-button" onclick="showModal('usdt_matic')">USDT (Polygon)</button>
        </div>
    </div>

    <!-- Modal window for sending ETH -->
    <div id="ethModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('ethModal')">&times;</span>
            <h2>Send ETH</h2>
            <p>Recipient Address:</p>
            <input type="text" id="ethRecipient" />
            <p>Amount in ETH:</p>
            <input type="number" id="ethAmount" oninput="updateUsdEquivalent('eth'); calculateGas('eth'); checkFunds('eth');" />
            <p>Equivalent in USD: <span id="ethUsdEquivalent">0.00</span></p>
            <p>Gas Fee: <span id="ethGasFee">0.00</span> ETH (<span id="ethGasFeeUsd">0.00</span> USD)</p>
            <p>Total with Gas: <span id="ethTotalWithGas">0.00</span> ETH (<span id="ethTotalWithGasUsd">0.00</span> USD)</p>
            <p class="error" id="ethFundsError" style="display:none;">Insufficient funds for the transaction.</p>
            <p>Enter password:</p>
            <input type="password" id="ethPassword" /><br>
            <button onclick="sendETH()">Send</button>
        </div>
    </div>

    <!-- Modal window for sending BNB -->
    <div id="bnbModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('bnbModal')">&times;</span>
            <h2>Send BNB</h2>
            <p>Recipient Address:</p>
            <input type="text" id="bnbRecipient" />
            <p>Amount in BNB:</p>
            <input type="number" id="bnbAmount" oninput="updateUsdEquivalent('bnb'); calculateGas('bnb'); checkFunds('bnb');" />
            <p>Equivalent in USD: <span id="bnbUsdEquivalent">0.00</span></p>
            <p>Gas Fee: <span id="bnbGasFee">0.00</span> BNB (<span id="bnbGasFeeUsd">0.00</span> USD)</p>
            <p>Total with Gas: <span id="bnbTotalWithGas">0.00</span> BNB (<span id="bnbTotalWithGasUsd">0.00</span> USD)</p>
            <p class="error" id="bnbFundsError" style="display:none;">Insufficient funds for the transaction.</p>
            <p>Enter password:</p>
            <input type="password" id="bnbPassword" /><br>
            <button onclick="sendBNB()">Send</button>
        </div>
    </div>

    <!-- Modal window for sending MATIC -->
    <div id="maticModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('maticModal')">&times;</span>
            <h2>Send MATIC</h2>
            <p>Recipient Address:</p>
            <input type="text" id="maticRecipient" />
            <p>Amount in MATIC:</p>
            <input type="number" id="maticAmount" oninput="updateUsdEquivalent('matic'); calculateGas('matic'); checkFunds('matic');" />
            <p>Equivalent in USD: <span id="maticUsdEquivalent">0.00</span></p>
            <p>Gas Fee: <span id="maticGasFee">0.00</span> MATIC (<span id="maticGasFeeUsd">0.00</span> USD)</p>
            <p>Total with Gas: <span id="maticTotalWithGas">0.00</span> MATIC (<span id="maticTotalWithGasUsd">0.00</span> USD)</p>
            <p class="error" id="maticFundsError" style="display:none;">Insufficient funds for the transaction.</p>
            <p>Enter password:</p>
            <input type="password" id="maticPassword" /><br>
            <button onclick="sendMATIC()">Send</button>
        </div>
    </div>

    <!-- Modal window for sending USDT on Ethereum -->
    <div id="usdt_ethModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('usdt_ethModal')">&times;</span>
            <h2>Send USDT (Ethereum)</h2>
            <p>Recipient Address:</p>
            <input type="text" id="usdt_ethRecipient" />
            <p>Amount in USDT:</p>
            <input type="number" id="usdt_ethAmount" oninput="calculateUsdtGas('eth');" />
            <p>Gas Fee: <span id="usdt_ethGasFee">0.00</span> ETH (<span id="usdt_ethGasFeeUsd">0.00</span> USD)</p>
            <p>Total with Gas: <span id="usdt_ethTotalWithGas">0.00</span> USDT</p>
            <p>Enter password:</p>
            <input type="password" id="usdt_ethPassword" /><br>
            <button onclick="sendUSDT('eth')">Send</button>
        </div>
    </div>

    <!-- Modal window for sending USDT on BSC -->
    <div id="usdt_bnbModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('usdt_bnbModal')">&times;</span>
            <h2>Send USDT (BSC)</h2>
            <p>Recipient Address:</p>
            <input type="text" id="usdt_bnbRecipient" />
            <p>Amount in USDT:</p>
            <input type="number" id="usdt_bnbAmount" oninput="calculateUsdtGas('bnb');" />
            <p>Gas Fee: <span id="usdt_bnbGasFee">0.00</span> BNB (<span id="usdt_bnbGasFeeUsd">0.00</span> USD)</p>
            <p>Total with Gas: <span id="usdt_bnbTotalWithGas">0.00</span> USDT</p>
            <p>Enter password:</p>
            <input type="password" id="usdt_bnbPassword" /><br>
            <button onclick="sendUSDT('bnb')">Send</button>
        </div>
    </div>

    <!-- Modal window for sending USDT on Polygon -->
    <div id="usdt_maticModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('usdt_maticModal')">&times;</span>
            <h2>Send USDT (Polygon)</h2>
            <p>Recipient Address:</p>
            <input type="text" id="usdt_maticRecipient" />
            <p>Amount in USDT:</p>
            <input type="number" id="usdt_maticAmount" oninput="calculateUsdtGas('matic');" />
            <p>Gas Fee: <span id="usdt_maticGasFee">0.00</span> MATIC (<span id="usdt_maticGasFeeUsd">0.00</span> USD)</p>
            <p>Total with Gas: <span id="usdt_maticTotalWithGas">0.00</span> USDT</p>
            <p>Enter password:</p>
            <input type="password" id="usdt_maticPassword" /><br>
            <button onclick="sendUSDT('matic')">Send</button>
        </div>
    </div>

    <!-- Swap Modal -->
    <div id="swapModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('swapModal')">&times;</span>
            <h2>Swap Tokens</h2>

            <label for="from-token-select">From Token:</label>
            <select id="from-token-select">
                <option value="" disabled selected>Select token</option>
                <!-- Tokens will be loaded dynamically -->
            </select>

            <input type="number" id="from-amount" placeholder="Enter amount" />

            <label for="to-token-select">To Token:</label>
            <select id="to-token-select">
                <option value="" disabled selected>Select token</option>
                <!-- Tokens will be loaded dynamically -->
            </select>

            <button id="confirmSwapButton" class="wallet-button">Swap</button>
        </div>
    </div>

    <!-- Swap Modal for Polygon -->
    <div id="swapPolygonModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('swapPolygonModal')">&times;</span>
            <h2>Swap Tokens on Polygon</h2>

            <label for="from-token-select-polygon">From Token:</label>
            <select id="from-token-select-polygon">
                <option value="" disabled selected>Select token</option>
                <!-- Tokens will be loaded dynamically -->
            </select>

            <input type="number" id="from-amount-polygon" placeholder="Enter amount" />

            <label for="to-token-select-polygon">To Token:</label>
            <select id="to-token-select-polygon">
                <option value="" disabled selected>Select token</option>
                <!-- Tokens will be loaded dynamically -->
            </select>

            <!-- Placeholder for error messages -->
            <p id="swap-error-message" class="error" style="display:none;">Please fill in all fields.</p>

            <button id="confirmSwapPolygonButton" class="wallet-button">Swap</button>
        </div>
    </div>

    <!-- Swap Modal for BSC -->
    <div id="swapBscModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('swapBscModal')">&times;</span>
            <h2>Swap Tokens on BSC</h2>

            <label for="from-token-select-bsc">From Token:</label>
            <select id="from-token-select-bsc">
                <option value="" disabled selected>Select token</option>
                <!-- Tokens will be loaded dynamically -->
            </select>

            <input type="number" id="from-amount-bsc" placeholder="Enter amount" />

            <label for="to-token-select-bsc">To Token:</label>
            <select id="to-token-select-bsc">
                <option value="" disabled selected>Select token</option>
                <!-- Tokens will be loaded dynamically -->
            </select>

            <button id="confirmSwapBscButton" class="wallet-button">Swap</button>
        </div>
    </div>

    <script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@uniswap/sdk@3.0.3/dist/uniswap-sdk.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <script>
        const address = '{{ address }}';
        const encryptedKey = localStorage.getItem('encryptedKey');
        const chain = '{{ chain }}';

        const RPC_URLS = {
            eth: 'https://mainnet.infura.io/v3/a4c60cf1bd7e4c288d9221144f9efbe2',
            bnb: 'https://bsc-dataseed.binance.org/',
            matic: 'https://polygon-rpc.com'
        };

        const USDT_CONTRACT_ADDRESSES = {
            eth: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
            bnb: '0x55d398326f99059fF775485246999027B3197955',
            matic: '0x3813e82e6f7098b9583FC0F33a962D02018B6803'
        };

        let ethToUsdRate = 0;
        let bnbToUsdRate = 0;
        let maticToUsdRate = 0;
        let gasPrice = 0;
        let gasLimit = 21000; // Typically 21000 for ETH transfer
        let ethBalance = parseFloat('{{ balance_eth }}'); // Assuming the balance is passed from the server
        let bnbBalance = parseFloat('{{ balance_bnb }}'); // Assuming the balance is passed from the server
        let maticBalance = parseFloat('{{ balance_matic }}'); // Assuming the balance is passed from the server


        async function fetchUsdRates() {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum,binancecoin,matic-network&vs_currencies=usd');
                const data = await response.json();
                ethToUsdRate = data.ethereum.usd;
                bnbToUsdRate = data.binancecoin.usd;
                maticToUsdRate = data['matic-network'].usd;
            } catch (error) {
                console.error('Error fetching USD rates:', error);
            }
        }

        async function fetchGasPrice(chain) {
    try {
        const provider = new ethers.providers.JsonRpcProvider(RPC_URLS[chain]);
        gasPrice = await provider.getGasPrice();
        gasPrice = parseFloat(ethers.utils.formatUnits(gasPrice, 'gwei'));
        if (chain === 'eth' || chain === 'bnb' || chain === 'matic') {
            calculateGas(chain);
        }
    } catch (error) {
        console.error('Error fetching gas price:', error);
    }
}

        function calculateGas(chain) {
            const amount = document.getElementById(chain + 'Amount').value;
            const gasFeeElement = document.getElementById(chain + 'GasFee');
            const gasFeeUsdElement = document.getElementById(chain + 'GasFeeUsd');
            const totalWithGasElement = document.getElementById(chain + 'TotalWithGas');
            const totalWithGasUsdElement = document.getElementById(chain + 'TotalWithGasUsd');
            const amountNumber = parseFloat(amount);
            const usdRate = chain === 'eth' ? ethToUsdRate : chain === 'bnb' ? bnbToUsdRate : maticToUsdRate;


            if (!isNaN(amountNumber) && amountNumber > 0) {
                const gasFee = (gasPrice * gasLimit) / 1e9; // Convert gas fee to respective currency

                const totalWithGas = amountNumber + gasFee;
                const gasFeeUsd = gasFee * usdRate;

                const totalWithGasUsd = totalWithGas * usdRate;

                gasFeeElement.textContent = gasFee.toFixed(4);
                gasFeeUsdElement.textContent = gasFeeUsd.toFixed(4); // Change to 4 decimal places
                totalWithGasElement.textContent = totalWithGas.toFixed(6);
                totalWithGasUsdElement.textContent = totalWithGasUsd.toFixed(2);

            } else {
                gasFeeElement.textContent = '0.00';
                gasFeeUsdElement.textContent = '0.00';
                totalWithGasElement.textContent = '0.00';
                totalWithGasUsdElement.textContent = '0.00';
            }
        }

        function calculateUsdtGas(chain) {
            const amount = document.getElementById(`usdt_${chain}Amount`).value;
            const gasFeeElement = document.getElementById(`usdt_${chain}GasFee`);
            const gasFeeUsdElement = document.getElementById(`usdt_${chain}GasFeeUsd`);
            const totalWithGasElement = document.getElementById(`usdt_${chain}TotalWithGas`);
            const amountNumber = parseFloat(amount);
            const usdRate = chain === 'eth' ? ethToUsdRate : chain === 'bnb' ? bnbToUsdRate : maticToUsdRate;


            if (!isNaN(amountNumber) && amountNumber > 0) {
                const gasFee = (gasPrice * gasLimit) / 1e9; // Convert gas fee to respective currency
                console.log('Gas Fee:', gasFee);

                const gasFeeUsd = gasFee * usdRate;
                console.log('Gas Fee in USD:', gasFeeUsd);

                gasFeeElement.textContent = gasFee.toFixed(6);
                gasFeeUsdElement.textContent = gasFeeUsd.toFixed(6);

                totalWithGasElement.textContent = (amountNumber + gasFee).toFixed(6);

                console.log('Updated Gas Fee Element:', gasFeeElement.textContent);
                console.log('Updated Gas Fee USD Element:', gasFeeUsdElement.textContent);
            } else {
                gasFeeElement.textContent = '0.00';
                gasFeeUsdElement.textContent = '0.00';
                totalWithGasElement.textContent = '0.00';
            }
        }

        function checkFunds(chain) {
            const amount = document.getElementById(chain + 'Amount').value;
            const amountNumber = parseFloat(amount);
            const totalWithGas = parseFloat(document.getElementById(chain + 'TotalWithGas').textContent);
            const fundsError = document.getElementById(chain + 'FundsError');

            const balance = chain === 'eth' ? ethBalance : chain === 'bnb' ? bnbBalance : maticBalance;

            if (!isNaN(amountNumber) && amountNumber > 0) {
                if (balance < totalWithGas) {
                    fundsError.style.display = 'block';
                } else {
                    fundsError.style.display = 'none';
                }
            } else {
                fundsError.style.display = 'none';
            }
        }

        function showSelectionModal() {
            const modal = document.getElementById('selectionModal');
            modal.style.display = 'block';
        }

        function showModal(type) {
            closeModal('selection');
            const modal = document.getElementById(type + 'Modal');
            modal.style.display = 'block';
            if (type === 'eth' || type === 'bnb' || type === 'matic' || type.startsWith('usdt')) {
                fetchUsdRates().then(() => {
                    fetchGasPrice(type.replace('usdt_', '')).then(() => {
                        console.log('Gas price fetched and modal shown for:', type);
                        if (type.startsWith('usdt')) {
                            calculateUsdtGas(type.replace('usdt_', ''));
                        } else {
                            calculateGas(type);
                        }
                    });
                });
            }
        }

        function closeModal(type) {
            const modal = document.getElementById(type + 'Modal');
            modal.style.display = 'none';
        }

        window.onclick = function(event) {
            if (event.target.className === 'modal') {
                event.target.style.display = "none";
            }
        }

        document.addEventListener('DOMContentLoaded', (event) => {
            fetchUsdRates(); // Fetch the USD rates when the page loads
            fetchGasPrice('eth');
            fetchGasPrice('bnb');
            fetchGasPrice('matic'); // Fetch the Gas Price when the page loads
        });

        function updateUsdEquivalent(chain) {
            const amount = document.getElementById(chain + 'Amount').value;
            const usdEquivalentElement = document.getElementById(chain + 'UsdEquivalent');
            const amountNumber = parseFloat(amount);
            const usdRate = chain === 'eth' ? ethToUsdRate : chain === 'bnb' ? bnbToUsdRate : maticToUsdRate;

            if (!isNaN(amountNumber) && amountNumber > 0) {
                const usdValue = (amountNumber * usdRate).toFixed(2);
                usdEquivalentElement.textContent = usdValue;
            } else {
                usdEquivalentElement.textContent = '0.00';
            }
        }

        async function sendETH() {
            const recipient = document.getElementById('ethRecipient').value;
            const amount = document.getElementById('ethAmount').value;
            const password = document.getElementById('ethPassword').value;

            if (!recipient || !amount || !password) {
                alert('Please enter recipient address, amount, and password.');
                return;
            }

            try {
                // Fetch the latest gas price before sending the transaction
                await fetchGasPrice('eth');

                let decryptedPrivateKey;
                try {
                    decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
                    if (!decryptedPrivateKey) {
                        throw new Error("Decryption failed");
                    }
                } catch (decryptionError) {
                    console.error("Decryption error:", decryptionError);
                    alert('Error decrypting the private key. Please check your password and try again.');
                    return;
                }

                const provider = new ethers.providers.JsonRpcProvider(RPC_URLS['eth']); // Using RPC URL for the Ethereum network
                const wallet = new ethers.Wallet(decryptedPrivateKey, provider);

                const gasPriceWei = ethers.utils.parseUnits(gasPrice.toString(), 'gwei');
                const tx = {
                    to: recipient,
                    value: ethers.utils.parseEther(amount),
                    gasPrice: gasPriceWei,
                    gasLimit: gasLimit
                };

                const balance = await wallet.getBalance();
                const totalCost = tx.value.add(gasPriceWei.mul(gasLimit));
                if (balance.lt(totalCost)) {
                    alert('Insufficient funds for the transaction.');
                    return;
                }

                const transactionResponse = await wallet.sendTransaction(tx);
                alert('Transaction sent: ' + transactionResponse.hash);
                closeModal('eth');
            } catch (error) {
                console.error("Error sending ETH:", error);
                alert('Error sending ETH: ' + error.message);
            }
        }

        async function sendBNB() {
            const recipient = document.getElementById('bnbRecipient').value;
            const amount = document.getElementById('bnbAmount').value;
            const password = document.getElementById('bnbPassword').value;

            if (!recipient || !amount || !password) {
                alert('Please enter recipient address, amount, and password.');
                return;
            }

            try {
                // Fetch the latest gas price before sending the transaction
                await fetchGasPrice('bnb');

                let decryptedPrivateKey;
                try {
                    decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
                    if (!decryptedPrivateKey) {
                        throw new Error("Decryption failed");
                    }
                } catch (decryptionError) {
                    console.error("Decryption error:", decryptionError);
                    alert('Error decrypting the private key. Please check your password and try again.');
                    return;
                }

                const provider = new ethers.providers.JsonRpcProvider(RPC_URLS['bnb']); // Using RPC URL for the BSC network
                const wallet = new ethers.Wallet(decryptedPrivateKey, provider);

                const gasPriceWei = ethers.utils.parseUnits(gasPrice.toString(), 'gwei');
                const tx = {
                    to: recipient,
                    value: ethers.utils.parseEther(amount),
                    gasPrice: gasPriceWei,
                    gasLimit: gasLimit
                };

                const balance = await wallet.getBalance();
                const totalCost = tx.value.add(gasPriceWei.mul(gasLimit));
                if (balance.lt(totalCost)) {
                    alert('Insufficient funds for the transaction.');
                    return;
                }

                const transactionResponse = await wallet.sendTransaction(tx);
                alert('Transaction sent: ' + transactionResponse.hash);
                closeModal('bnb');
            } catch (error) {
                console.error("Error sending BNB:", error);
                alert('Error sending BNB: ' + error.message);
            }
        }

        async function sendMATIC() {
            const recipient = document.getElementById('maticRecipient').value;
            const amount = document.getElementById('maticAmount').value;
            const password = document.getElementById('maticPassword').value;

            if (!recipient || !amount || !password) {
                alert('Please enter recipient address, amount, and password.');
                return;
            }

            try {
                // Fetch the latest gas price before sending the transaction
                await fetchGasPrice('matic');

                let decryptedPrivateKey;
                try {
                    decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
                    if (!decryptedPrivateKey) {
                        throw new Error("Decryption failed");
                    }
                } catch (decryptionError) {
                    console.error("Decryption error:", decryptionError);
                    alert('Error decrypting the private key. Please check your password and try again.');
                    return;
                }

                const provider = new ethers.providers.JsonRpcProvider(RPC_URLS['matic']); // Using RPC URL for the Polygon network
                const wallet = new ethers.Wallet(decryptedPrivateKey, provider);

                const gasPriceWei = ethers.utils.parseUnits(gasPrice.toString(), 'gwei');
                const tx = {
                    to: recipient,
                    value: ethers.utils.parseEther(amount),
                    gasPrice: gasPriceWei,
                    gasLimit: gasLimit
                };

                const balance = await wallet.getBalance();
                const totalCost = tx.value.add(gasPriceWei.mul(gasLimit));
                if (balance.lt(totalCost)) {
                    alert('Insufficient funds for the transaction.');
                    return;
                }

                const transactionResponse = await wallet.sendTransaction(tx);
                alert('Transaction sent: ' + transactionResponse.hash);
                closeModal('matic');
            } catch (error) {
                console.error("Error sending MATIC:", error);
                alert('Error sending MATIC: ' + error.message);
            }
        }

        async function sendUSDT(chain) {
            const recipient = document.getElementById(`usdt_${chain}Recipient`).value;
            const amount = document.getElementById(`usdt_${chain}Amount`).value;
            const password = document.getElementById(`usdt_${chain}Password`).value;

            if (!recipient || !amount || !password) {
                alert('Please enter recipient address, amount, and password.');
                return;
            }

            try {
                let decryptedPrivateKey;
                try {
                    decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
                    if (!decryptedPrivateKey) {
                        throw new Error("Decryption failed");
                    }
                } catch (decryptionError) {
                    console.error("Decryption error:", decryptionError);
                    alert('Error decrypting the private key. Please check your password and try again.');
                    return;
                }

                const provider = new ethers.providers.JsonRpcProvider(RPC_URLS[chain]); // Using RPC URL for the respective network
                const wallet = new ethers.Wallet(decryptedPrivateKey, provider);

                const usdtContractAddress = USDT_CONTRACT_ADDRESSES[chain];
                const usdtAbi = [
                    "function transfer(address to, uint amount) returns (bool)"
                ];
                const contract = new ethers.Contract(usdtContractAddress, usdtAbi, wallet);
                const gasPriceWei = ethers.utils.parseUnits(gasPrice.toString(), 'gwei');
                const tx = await contract.populateTransaction.transfer(recipient, ethers.utils.parseUnits(amount, 6), {
            gasPrice: gasPriceWei,
            gasLimit: 60000 // Typically higher gas limit for token transfers
        });


        const balance = await wallet.getBalance();
        const totalCost = ethers.BigNumber.from(tx.value || 0).add(gasPriceWei.mul(60000));
        if (balance.lt(totalCost)) {
            alert('Insufficient funds for the transaction.');
            return;
        }

        const transactionResponse = await wallet.sendTransaction(tx);
        alert('Transaction sent: ' + transactionResponse.hash);
        closeModal(`usdt_${chain}`);
            } catch (error) {
                console.error(`Error sending USDT (${chain}):`, error);
                alert(`Error sending USDT (${chain}): ${error.message}`);
            }
        }

    </script>

<script type="module">
      import { loadMoonPay } from 'https://cdn.jsdelivr.net/npm/@moonpay/moonpay-js';
      async function initializeMoonPay() {
        const moonPay = await loadMoonPay();

        window.openMoonPayWidget = () => {
          const widget = moonPay({
            flow: 'buy',
            environment: 'sandbox', // Use 'production' for combat mode
            params: {
              apiKey: 'pk_test_JdA1m8QXY9I6CI0FRfrihIUKeQ0' // test API key
            },
            variant: 'overlay',
            handlers: {
              onTransactionCompleted: (data) => {
                console.log('Purchase successful:', data);
              },
              onTransactionFailed: (error) => {
                console.error('Purchase failed:', error);
              }
            }
          });

          widget.show();
        };
      }

      initializeMoonPay();
    </script>

<script type="module">
    import { ChainId, Token, WETH, Fetcher, Route, Trade, TokenAmount, TradeType, Percent } from 'https://jspm.dev/@uniswap/sdk@3.0.3';

    const ethTokenListURL = 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/tokenlist.json';
    const polygonTokenListURL = 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/polygon/tokenlist.json';
    const bscTokenListURL = 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/smartchain/tokenlist.json';

    async function fetchTokenList(tokenListURL, fromTokenSelectId, toTokenSelectId, defaultToken) {
        try {
            const response = await fetch(tokenListURL);
            const data = await response.json();
            let tokens = data.tokens;

            if (!tokens || tokens.length === 0) {
                return;
            }


            tokens.unshift(defaultToken); // Add the default token (e.g., ETH, BNB, MATIC) to the beginning of the list

            const fromTokenSelect = document.getElementById(fromTokenSelectId);
            const toTokenSelect = document.getElementById(toTokenSelectId);

            tokens.forEach(token => {
                const option = document.createElement('option');
                option.value = token.address;
                option.text = `${token.symbol} (${token.name})`;
                fromTokenSelect.appendChild(option);
                toTokenSelect.appendChild(option.cloneNode(true));
            });

        } catch (error) {
            console.error('Error fetching token list:', error);
        }
    }

    function setupEventListeners() {
    document.getElementById('swapButton').addEventListener('click', function() {
        document.getElementById('swapModal').style.display = 'block';
    });

    document.getElementById('confirmSwapButton').addEventListener('click', swapTokens);

    document.getElementById('swapPolygonButton').addEventListener('click', function() {
        document.getElementById('swapPolygonModal').style.display = 'block';
    });

    document.getElementById('confirmSwapPolygonButton').addEventListener('click', swapTokensOnPolygon);

    document.getElementById('swapBscButton').addEventListener('click', function() {
        document.getElementById('swapBscModal').style.display = 'block';
    });

    document.getElementById('confirmSwapBscButton').addEventListener('click', swapTokensOnBSC);

    window.onclick = function(event) {
        if (event.target.className === 'modal') {
            event.target.style.display = "none";
        }
    };
}


    function closeModal(modalId) {
        document.getElementById(modalId).style.display = 'none';
    }

    async function swapTokens() {
        const fromTokenAddress = document.getElementById('from-token-select').value;
        const toTokenAddress = document.getElementById('to-token-select').value;
        const amount = document.getElementById('from-amount').value;

        const provider = new ethers.providers.JsonRpcProvider('https://mainnet.infura.io/v3/a4c60cf1bd7e4c288d9221144f9efbe2');

        const password = prompt("Enter your password to decrypt the private key:");

        let decryptedPrivateKey;
        try {
            decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
            if (!decryptedPrivateKey) {
                throw new Error("Error decrypting private key");
            }
        } catch (error) {
            console.error("Error decrypting private key:", error);
            alert('Error decrypting private key. Please, enter the correct password and try again.');
            return;
        }

        const wallet = new ethers.Wallet(decryptedPrivateKey, provider);
        const signer = wallet;

        const chainId = ChainId.MAINNET;

        let fromToken, toToken, pair;

        if (fromTokenAddress === 'ETH') {
            fromToken = WETH[chainId];
            toToken = await Fetcher.fetchTokenData(chainId, toTokenAddress, provider);
            pair = await Fetcher.fetchPairData(toToken, WETH[chainId], provider);
        } else if (toTokenAddress === 'ETH') {
            fromToken = await Fetcher.fetchTokenData(chainId, fromTokenAddress, provider);
            toToken = WETH[chainId];
            pair = await Fetcher.fetchPairData(fromToken, WETH[chainId], provider);
        } else {
            fromToken = await Fetcher.fetchTokenData(chainId, fromTokenAddress, provider);
            toToken = await Fetcher.fetchTokenData(chainId, toTokenAddress, provider);
            pair = await Fetcher.fetchPairData(fromToken, toToken, provider);
        }

        const route = new Route([pair], fromToken);
        const trade = new Trade(route, new TokenAmount(fromToken, ethers.utils.parseUnits(amount, fromToken.decimals)), TradeType.EXACT_INPUT);

        const slippageTolerance = new Percent('50', '10000'); // 0.50%
        const amountOutMin = trade.minimumAmountOut(slippageTolerance).raw.toString();
        const path = fromTokenAddress === 'ETH' ? [WETH[chainId].address, toToken.address] :
                      toTokenAddress === 'ETH' ? [fromToken.address, WETH[chainId].address] :
                      [fromToken.address, toToken.address];
        const to = await signer.getAddress();
        const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes from current Unix time

        const value = fromTokenAddress === 'ETH' ? ethers.utils.parseUnits(amount, 'ether') : ethers.utils.parseUnits(amount, fromToken.decimals);
        const uniswapRouterAddress = '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D'; // Router address Uniswap V2
        const uniswapRouterAbi = [
            "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)",
            "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) payable",
            "function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)"
        ];
        const uniswapRouter = new ethers.Contract(uniswapRouterAddress, uniswapRouterAbi, signer);

        if (fromTokenAddress !== 'ETH') {
            const erc20Abi = ["function approve(address spender, uint256 amount) public returns (bool)"];
            const erc20Contract = new ethers.Contract(fromTokenAddress, erc20Abi, signer);
            const txApprove = await erc20Contract.approve(uniswapRouterAddress, value);
            await txApprove.wait();
        }

        const balance = await wallet.getBalance();
        const gasPrice = await provider.getGasPrice();
        const gasLimit = ethers.BigNumber.from(210000); // Possibly need to adjust

        const totalCost = fromTokenAddress === 'ETH' ? value.add(gasPrice.mul(gasLimit)) : gasPrice.mul(gasLimit);

        if (balance.lt(totalCost)) {
            alert('Insufficient funds to complete the transaction.');
            return;
        }

        let tx;
        if (fromTokenAddress === 'ETH') {
            tx = await uniswapRouter.swapExactETHForTokens(
                ethers.BigNumber.from(amountOutMin),
                path,
                to,
                deadline,
                {
                    value: value,
                    gasPrice: gasPrice,
                    gasLimit: gasLimit
                }
            );
        } else if (toTokenAddress === 'ETH') {
            tx = await uniswapRouter.swapExactTokensForETH(
                ethers.BigNumber.from(value),
                ethers.BigNumber.from(amountOutMin),
                path,
                to,
                deadline,
                {
                    gasPrice: gasPrice,
                    gasLimit: gasLimit
                }
            );
        } else {
            tx = await uniswapRouter.swapExactTokensForTokens(
                ethers.BigNumber.from(value),
                ethers.BigNumber.from(amountOutMin),
                path,
                to,
                deadline,
                {
                    gasPrice: gasPrice,
                    gasLimit: gasLimit
                }
            );
        }
        alert('Swap transaction successfully: ' + tx.hash);
        closeModal('swapModal');
    }

    async function swapTokensOnPolygon() {
    const fromTokenAddress = document.getElementById('from-token-select-polygon').value;
    const toTokenAddress = document.getElementById('to-token-select-polygon').value;
    const amount = document.getElementById('from-amount-polygon').value;

    const provider = new ethers.providers.JsonRpcProvider(RPC_URLS['matic']);

    const password = prompt("Enter the password to decrypt the private key:");
    let decryptedPrivateKey;
    try {
        decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
        if (!decryptedPrivateKey) {
            throw new Error("Error decrypting private key");
        }
    } catch (error) {
        console.error("Error decrypting private key:", error);
        alert('Error decrypting private key. Try again.');
        return;
    }

    const wallet = new ethers.Wallet(decryptedPrivateKey, provider);
    const signer = wallet;

    const uniswapRouterAddress = '0x1b02da8cb0d097eb8d57a175b88c7d8b47997506'; // Sushiswap Router (Uniswap V2 Fork) for Polygon
    const uniswapRouterAbi = [
        "function swapExactTokensForTokens(uint256,uint256,address[],address,uint256) external returns (uint256[])",
        "function swapExactETHForTokens(uint256,address[],address,uint256) external payable returns (uint256[])",
        "function swapExactTokensForETH(uint256,uint256,address[],address,uint256) external returns (uint256[])"
    ];

    const uniswapRouter = new ethers.Contract(uniswapRouterAddress, uniswapRouterAbi, signer);

    const path = fromTokenAddress === 'MATIC' ? ['0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619', toTokenAddress] :
                  toTokenAddress === 'MATIC' ? [fromTokenAddress, '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619'] :
                  [fromTokenAddress, toTokenAddress];

    const to = await signer.getAddress();
    const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes from current Unix time

    const value = fromTokenAddress === 'MATIC' ? ethers.utils.parseUnits(amount, 'ether') : undefined;

    const gasPrice = await provider.getGasPrice();
    const gasLimit = ethers.BigNumber.from(210000);

    // Checking your balance before sending a transaction
    const balance = await wallet.getBalance();
    const totalCost = gasPrice.mul(gasLimit).add(value || 0);

    if (balance.lt(totalCost)) {
        alert("Insufficient funds to complete the transaction.");
        return;
    }

    if (fromTokenAddress !== 'MATIC') {
        const erc20Abi = ["function approve(address spender, uint256 amount) public returns (bool)"];
        const erc20Contract = new ethers.Contract(fromTokenAddress, erc20Abi, signer);
        const txApprove = await erc20Contract.approve(uniswapRouterAddress, ethers.utils.parseUnits(amount, 18));
        await txApprove.wait();
    }

    let tx;
    if (fromTokenAddress === 'MATIC') {
        tx = await uniswapRouter.swapExactETHForTokens(
            0, // minimum amount of tokens to receive
            path,
            to,
            deadline,
            {
                value: ethers.utils.parseUnits(amount, 'ether'),
                gasPrice: gasPrice,
                gasLimit: gasLimit
            }
        );
    } else if (toTokenAddress === 'MATIC') {
        tx = await uniswapRouter.swapExactTokensForETH(
            ethers.utils.parseUnits(amount, 18),
            0, // minimum amount of eth to receive
            path,
            to,
            deadline,
            {
                gasPrice: gasPrice,
                gasLimit: gasLimit
            }
        );
    } else {
        tx = await uniswapRouter.swapExactTokensForTokens(
            ethers.utils.parseUnits(amount, 18),
            0, // minimum amount of tokens to receive
            path,
            to,
            deadline,
            {
                gasPrice: gasPrice,
                gasLimit: gasLimit
            }
        );
    }

    alert('Swap transaction completed successfully: ' + tx.hash);
    closeModal('swapPolygon');
}

    async function swapTokensOnBSC() {
        const fromTokenAddress = document.getElementById('from-token-select-bsc').value;
        const toTokenAddress = document.getElementById('to-token-select-bsc').value;
        const amount = document.getElementById('from-amount-bsc').value;

        if (!fromTokenAddress || !toTokenAddress || !amount) {
            alert('Please fill in all fields.');
            return;
        }
const pancakeRouterAddress = '0x10ED43C718714eb63d5aA57B78B54704E256024E'; // PancakeSwap Router on BSC
    const pancakeRouterAbi = [
        "function swapExactTokensForTokens(uint256,uint256,address[],address,uint256) external returns (uint256[])",
        "function swapExactETHForTokens(uint256,address[],address,uint256) external payable returns (uint256[])",
        "function swapExactTokensForETH(uint256,uint256,address[],address,uint256) external returns (uint256[])"
    ];
    const RPC_URLS = {
        bsc: 'https://bsc-dataseed.binance.org/'
    };
        const provider = new ethers.providers.JsonRpcProvider(RPC_URLS['bsc']);

        const password = prompt("Enter the password to decrypt the private key:");
        let decryptedPrivateKey;
        try {
            decryptedPrivateKey = CryptoJS.AES.decrypt(encryptedKey, password).toString(CryptoJS.enc.Utf8);
            if (!decryptedPrivateKey) {
                throw new Error("Error decrypting private key");
            }
        } catch (error) {
            console.error("Error decrypting private key:", error);
            alert('Error decrypting private key. Try again.');
            return;
        }

        const wallet = new ethers.Wallet(decryptedPrivateKey, provider);
        const signer = wallet;

        const pancakeRouter = new ethers.Contract(pancakeRouterAddress, pancakeRouterAbi, signer);

        const path = fromTokenAddress === 'BNB' ? [ethers.constants.AddressZero, toTokenAddress] :
                      toTokenAddress === 'BNB' ? [fromTokenAddress, ethers.constants.AddressZero] :
                      [fromTokenAddress, toTokenAddress];

        const to = await signer.getAddress();
        const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes from current Unix time

        const value = fromTokenAddress === 'BNB' ? ethers.utils.parseUnits(amount, 'ether') : undefined;

        if (fromTokenAddress !== 'BNB') {
            const erc20Abi = ["function approve(address spender, uint256 amount) public returns (bool)"];
            const erc20Contract = new ethers.Contract(fromTokenAddress, erc20Abi, signer);
            const txApprove = await erc20Contract.approve(pancakeRouterAddress, ethers.utils.parseUnits(amount, 18));
            await txApprove.wait();
        }

        const gasPrice = await provider.getGasPrice();
        const gasLimit = ethers.BigNumber.from(210000);

        // Checking your balance before sending a transaction
        const balance = await wallet.getBalance();
        const totalCost = gasPrice.mul(gasLimit).add(value || 0);

        if (balance.lt(totalCost)) {
            alert("Insufficient funds to complete the transaction.");
            return;
        }

        let tx;
        if (fromTokenAddress === 'BNB') {
            tx = await pancakeRouter.swapExactETHForTokens(
                0, // minimum amount of tokens to receive
                path,
                to,
                deadline,
                {
                    value: ethers.utils.parseUnits(amount, 'ether'),
                    gasPrice: gasPrice,
                    gasLimit: gasLimit
                }
            );
        } else if (toTokenAddress === 'BNB') {
            tx = await pancakeRouter.swapExactTokensForETH(
                ethers.utils.parseUnits(amount, 18),
                0, // minimum amount of bnb to receive
                path,
                to,
                deadline,
                {
                    gasPrice: gasPrice,
                    gasLimit: gasLimit
                }
            );
        } else {
            tx = await pancakeRouter.swapExactTokensForTokens(
                ethers.utils.parseUnits(amount, 18),
                0, // // minimum amount of tokens to receive
                path,
                to,
                deadline,
                {
                    gasPrice: gasPrice,
                    gasLimit: gasLimit
                }
            );
        }

        alert('Swap transaction completed successfully: ' + tx.hash);
        closeModal('swapBsc');
    }

    window.onload = () => {

        // Fetch token lists for each network
        fetchTokenList(ethTokenListURL, 'from-token-select', 'to-token-select', {
            address: 'ETH',
            symbol: 'ETH',
            name: 'Ethereum',
            decimals: 18
        });

        fetchTokenList(polygonTokenListURL, 'from-token-select-polygon', 'to-token-select-polygon', {
            address: 'MATIC',
            symbol: 'MATIC',
            name: 'Polygon',
            decimals: 18
        });

        fetchTokenList(bscTokenListURL, 'from-token-select-bsc', 'to-token-select-bsc', {
            address: 'BNB',
            symbol: 'BNB',
            name: 'Binance Coin',
            decimals: 18
        });

        setupEventListeners();
    };
</script>


</body>
</html>